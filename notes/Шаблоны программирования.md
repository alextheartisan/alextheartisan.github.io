# Шаблоны программирования

- [[Шаблон Observer]]
- [[Adapter]]
- [[Шаблон Decorator]]
- [[Шаблон Singleton]]

[[Event Emitter]]

[[State Machine]]

tags: #programming, #patterns

---

# Dependency injection

или _Внедрение зависимости_

Если нам требуется нанять нового человека, мы можем не создавать свой отдел
кадров, а внедрить зависимость от компании по подбору персонала. Она, свою
очередь, по нашему запросу «нужен человек», будет либо сама работать как отдел
кадров, либо же найдет другую компанию, которая предоставит данные услуги.

«Внедрение зависимости» позволяет перекладывать и взаимозаменять отдельные части
программы без потери общей функциональности.

#programming

---

# Design Patterns

❔ [Паттерны проектирования - просто отсутствующие фичи языка?](http://wiki.c2.com/?AreDesignPatternsMissingLanguageFeatures)

## Structural

- Adapter
- Bridge
- Facade
- Composite
- Decorator
- Front controller
- Flyweight
- Proxy / Surrogate

## Behavioral

- Chain of Responsibility
- Command

## Creational

http://gameprogrammingpatterns.com/contents.html

https://roadmap.sh/guides/design-patterns-for-humans

https://sourcemaking.com/design_patterns

https://github.com/addyosmani/essential-js-design-patterns
https://github.com/tcorral/Design-Patterns-in-Javascript
https://github.com/iluwatar/java-design-patterns
https://github.com/ochococo/Design-Patterns-In-Swift
https://github.com/faif/python-patterns
https://github.com/nslocum/design-patterns-in-ruby
https://github.com/domnikl/DesignPatternsPHP
https://github.com/karlpatrickespiritu/TLDR-Learning-JS-Design-Patterns-by-Addy-Osmani
https://github.com/robdodson/JavaScript-Design-Patterns
https://github.com/nnupoor/js_designpatterns

- [Sourcemaking](https://sourcemaking.com/)
- [Refactoring Guru](https://refactoring.guru)

* https://medium.com/@arturbasak/design-patterns-examples-in-javascript-creational-79812120f273

### Singleton

#### Cons

- [Почему синглтон — анти-паттерн?](http://rsdn.org/forum/design/2615563.1)
- [Why singletons are evil?](https://blogs.msdn.microsoft.com/scottdensmore/2004/05/25/why-singletons-are-evil/)
- [What is so bad about singletons?](https://stackoverflow.com/questions/137975/what-is-so-bad-about-singletons)

> singletons are the source of many problems that start in design and end in debugging

Главная проблема синглтона в том, что это первый паттерн описанный в GoF. На
него набрасываются и не замечают его недостатков, из коих:

##### Синглтон нарушает SRP (Single Responsibility Principle)

> Класс синглтона, помимо того чтобы выполнять свои непосредственные
> обязанности, занимается еще и контролированием количества своих экземпляров.

> Singletons allow you to limit creation of your objects. This is true, but now
> you are mixing two different responsibilities into the same class, which is a
> violation of the Single Responsibility Principle. A class should not care
> whether or not it is a singleton. It should be concerned with its business
> responsibilities only. If you want to limit the ability to instantiate some
> class, create a factory or builder object that encapsulates creation, and in
> there, limit creation as you wish. Now the responsibilities of creation are
> partitioned away from the responsibilities of the business entity.

##### Глобальное состояние

> Про вред глобальных переменных вроде бы уже все знают, но тут та же самая
> проблема. Когда мы получаем доступ к экземпляру класса, мы не знаем текущее
> состояние этого класса, и кто и когда его менял, и это состояние может быть
> вовсе не таким, как ожидается. Иными словами, корректность работы с синглтоном
> зависит от порядка обращений к нему, что вызывает неявную зависимость
> подсистем друг от друга и, как следствие, серьезно усложняет разработку.

> Singletons frequently are used to provide a global access point for some
> service. True, they do this, but at what cost? They provide a well-known point
> of access to some service in your application so that you don't have to pass
> around a reference to that service. How is that different from a global
> variable? (remember, globals are bad, right???) What ends up happening is that
> the dependencies in your design are hidden inside the code, and not visible by
> examining the interfaces of your classes and methods. You have to inspect the
> code to understand exactly what other objects your class uses. This is less
> clear than it could be. The urge to create something as a global to avoid
> passing it around is a smell in your design; it is not a feature of
> globals/singletons. If you examine your design more closely, you can almost
> always come up with a design that it is better and does not have to pass
> around tramp data to every object and method.

##### Тесное взаимодействие между классами

> Singletons promote tight coupling between classes. One of the underlying
> properties that makes code testable is that it is loosely coupled to its
> surroundings. This property allows you to substitute alternate implementations
> for collaborators during testing to achieve specific testing goals (think mock
> objects). Singletons tightly couple you to the exact type of the singleton
> object, removing the opportunity to use polymorphism to substitute an
> alternative. A better alternative, as discussed in the first point above, is
> to alter your design to allow you to pass references to objects to your
> classes and methods, which will reduce the coupling issues described above.

##### Singletons carry state with them that last as long as the program lasts

> Persistent state is the enemy of unit testing. One of the things that makes
> unit testing effective is that each test has to be independent of all the
> others. If this is not true, then the order in which the tests run affects the
> outcome of the tests. This can lead to cases where tests fail when they
> shouldn't, and even worse, it can lead to tests that pass just because of the
> order in which they were run. This can hide bugs and is evil. Avoiding static
> variables is a good way to prevent state from being carried from test to test.
> Singletons, by their very nature, depend on an instance that is held in a
> static variable. This is an invitation for test-dependence. Avoid this by
> passing references to objects to your classes and methods.

##### ---

> Зависимость обычного класса от синглтона не видна в публичном контракте
> класса. Так как обычно экземпляр синглтона не передается в параметрах метода,
> а получается напрямую, через GetInstance(), то для выявления зависимости
> класса от синглтона надо залезть в тело каждого метода — просто просмотреть
> публичный контракт объекта недостаточно.

##### ---

> Наличие синглтона понижает тестируемость приложения в целом и классов, которые
> используют синглтон, в частности. Во-первых, вместо синглтона нельзя
> подпихнуть Mock-объект, а во-вторых, если синглтон имеет интерфейс для
> изменения своего состояния, то тесты начинают зависеть друг от друга. Говоря
> же проще — синглтон повышает связность, и все вышеперечисленное, в том или
> ином виде, есть следствие повышения связности.

Естественно, можно акккуратненько пройти по граблям и использовать синглетон, но
(цитата из доки к пикоконтейнеру) "Overuse makes for bad solutions. At the
enterprise level, it makes for very very bad solutions"... Тем более, что при
тщательном рассмотрении вопроса, использования синглтона, как правило, можно
легко избежать. А если можно легко избежать, значит это нужно сделать, чтобы
удержать себя от излишнего соблазна "оверюза"... Например, для контроля
количества экземпляров объекта вполне можно (и нужно) использовать различного
рода фабрики. Наибольшая же опасность, как было сказано, подстерегает при
попытке построить на основе сиглтонов всю архитектуру приложения, такому подходу
существует масса замечательных альтернатив. Например, IoC контейнеры — там
проблема контроля создания сервисов решается естественным образом, так как они,
по сути, являются "фабриками на стероидах" =). Другой альтернативой являются
Service Locator-ы, из известных вариантов этого подхода — паттерн
IServiceProvider.

---

### Lazy initialization (отложенная инициализация)

Предположим, вы работаете в бухгалтерии и для каждого сотрудника вы должны
подготавливать «отчет о выплатах». Вы можете в начале каждого месяца делать этот
отчет на всех сотрудников, но некоторые отчеты могут не понадобиться, и тогда
скорее всего вы примените «отложенную инициализацию», то есть вы будете
подготавливать этот отчет только тогда, когда он будет запрошен начальством
(вышестоящим объектом). Однако начальство в любой момент времени может сказать
что у него этот отчет уже есть, но готов он уже или нет, оно не знает и знать не
должно. Данный паттерн служит для оптимизации ресурсов.

## Anti-patterns (Fun Patterns)

> Cмысл понятия «анти-паттерн» вовсе не в том, что он однозначно вреден и должен изничтожаться. «Aнти-паттерны» обычно терпимы в единичных случаях и представляют опасность, когда их много и архитектура приложения серьезно на них опирается.

- [lurkmore](http://lurkmore.to/%D0%90%D0%BD%D1%82%D0%B8-%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD)

### Hard Code

Про него ещё говорят «прибито гвоздями». Код настолько привязан к конкретной
аппаратной конфигурации и/или системному окружению, что оторвать его для
переноса в другое место можно только гвоздодёром.

### Soft Code

Код, конфигурируемый настолько гибко (и запутано), что хочется, чтобы лучше уж
это был hard code. Возникает вследствие выноса в файлы конфигурации программной
логики, что в разумных количествах, к слову, бывает иногда оправданно.

### Magic numbers, magic strings

То, на чём нередко строится hard code. Всяческие константы в программе без
пояснения их физического (или любого иного) смысла. Как правило, при изменении
магического числа или его удалении код магически перестаёт работать вовсе.
Типичные примеры — 17 и 54.

Магические строки, от англ. magic strings — как магические числа, но только это
строки.

### Magic button

Магическая кнопка, от англ. magic button — весь код написан в обработчике
нажатия кнопки. Этим страдают на всех языках с графическим редактором гуя — C#,
делфи.

### Race condition

Начинаются тогда, когда программист попадает в чудный мир параллельного
программирования с его нитями, потоками и семафорами.

### Accidental complexity

Делать сложно то, что можно сделать просто. Как правило, программисту хочется
побыстрее применить всё, что он изучил (и воон ту новую библиотеку для обмена
данными по протоколу XXX), а ещё заполучить по результатам проекта сразу много
новых строчек в резюме. Если это желание побеждает доводы рассудка, то в проекте
появляется accidental complexity. Также см. статьи Индусский код и KISS.

### Spaghetti code

Спагетти (рус. солянка) из кода, от англ. code spaghetti — это тот самый код,
который вам однажды дают сопровождать и после пяти минут причёсывания вставших
дыбом волос просмотра которого вы молча закрываете редактор и открываете броузер
на хуехантере.ру в поисках вакансии в более другой фирме, где не практикуют
такого жестокого обращения с программистами. Характеризуется тем, что в одном
куске кода описывается куча перемешанных до полного непонимания сущностей,
которые по-хорошему необходимо разделять. Например, HTML теги в PHP коде вместо
выноса всей верстки в шаблоны.

### Катамари

Катамари — внедрение новых возможностей исключительно в виде внешних костылей и
подпорок вместо периодического пересмотра базового функционала. В итоге со
временем код превращается в тугой комок какого-то нечта, в чём даже сами
разработчики отказываются ковыряться. В итоге получаем следующую порцию костылей
и подпорок. Может применяться как в отдельно взятом фрагменте кода, так и
глобально во всём проекте.

### God Object

Божественный Объект, от англ. God Object — небольшая часть кода, где
сконцентрировано всё. Буквально всё. Возможно, там даже прячется немаленьких
размеров галактика. Весь прочий код программы — исключительно декорация вокруг
Божественного Объекта.

### Detonator

Детонатор, от англ. detonator — очень распространён, но редко обнаруживаем.
Наглядный пример: использование в вычислениях с датами поля из двух цифр. Бомба
заложена, и детонатор рано или поздно сработает

### Absolver

Не-виноватая-я, англ. absolver — паттерн встречается в коде, написанном бывшими
сотрудниками компании. В таком коде заключено столько старых проблем, что
теперешние сотрудники могут защитить свои наработки от обвинений, утверждая, что
именно чужой код — причина всех возникающих ошибок. Также известен под именем
Это-Не-Моя-Правка.

### Stake

Исторический вклад, от англ. stake — паттерн имеет место в программе, написанной
сотрудником, который впоследствии получил продвижение по службе. Несмотря на
изобилие ошибок в программе, вклад этого сотрудника слишком велик, чтобы
позволить кому-либо начать переписывать код, поскольку он является апофеозом
технических достижений этого товарища.

### Паблик Морозов

Паблик Морозов (сугубо русская идиома, нет английского эквивалента) — класс,
который по запросу выдаёт доступ ко всем, даже приватным, свойствам
класса-родителя. Не столько плохо само по себе, сколько означает, что в коде
что-то не так.

### Private Ryan

Спасти рядового Райана, от англ. Private Ryan — паттерн, в котором доступ к полю
получить в принципе можно, но для этого надо снаряжать экспедицию, сопряженную
со множеством опасностей.

### Письмо Дяди Федора

Когда над задачей работают несколько человек

### Компост

_Фасад_ под которым - дерьмо

Big ball of mud. «Большой Ком Грязи» – термин для системы или просто программы,
которая не имеет хоть немного различимой архитектуры. Как правило, включает в
себя более одного антишаблона. Этим страдают системы, разработанные людьми без
подготовки в области архитектуры ПО.

Software Bloat. «Распухание ПО» – пренебрежительный термин, используемый для
описания тенденций развития новейших программ в направлении использования
бóльших объемов системных ресурсов (место на диске, ОЗУ), чем предшествующие
версии. В более общем контексте применяется для описания программ, которые
используют больше ресурсов, чем необходимо.

Yo-Yo problem. «Проблема Йо-Йо» возникает, когда необходимо разобраться в
программе, иерархия наследования и вложенность вызовов методов которой очень
длинна и сложна. Программисту вследствие этого необходимо лавировать между
множеством различных классов и методов, чтобы контролировать поведение
программы. Термин происходит от названия игрушки йо-йо.

Magic Button. Возникает, когда код обработки формы сконцентрирован в одном месте
и, естественно, никак не структурирован.

Magic Number. Наличие в коде многократно повторяющихся одинаковых чисел или
чисел, объяснение происхождения которых отсутствует.

Gas Factory. «Газовый Завод» – необязательный сложный дизайн или для простой
задачи.

Analiys paralisys. В разработке ПО «Паралич анализа» проявляет себя через
чрезвычайно длинные фазы планирования проекта, сбора необходимых для этого
артефактов, программного моделирования и дизайна, которые не имеют особого
смысла для достижения итоговой цели.

Interface Bloat. «Распухший Интерфейс» – термин, используемый для описания
интерфейсов, которые пытаются вместить в себя все возможные операции над
данными.

Smoke And Mirrors. Термин «Дым и Зеркала» используется, чтобы описать программу
либо функциональность, которая еще не существует, но выставляется за таковую.
Часто используется для демонстрации финального проекта и его функционала.

Improbability Factor. «Фактор Неправдоподобия» – ситуация, при которой в системе
наблюдается некоторая проблема. Часто программисты знают о проблеме, но им не
разрешено ее исправить отчасти из-за того, что шанс всплытия наружу у этой
проблемы очень мал. Как правило (следуя закону Мерфи), она всплывает и наносит
ущерб.

Сreeping featurism. Используется для описания ПО, которое выставляет напоказ
вновь разработанные элементы, доводя до высокой степени ущербности по сравнению
с ними другие аспекты дизайна, такие как простота, компактность и отсутствие
ошибок. Как правило, существует вера в то, что каждая новая маленькая черта
информационной системы увеличит ее стоимость.

Accidental complexity. «Случайная сложность» – проблема в программировании,
которой легко можно было избежать. Возникает вследствие неправильного понимания
проблемы или неэффективного планирования.

Ambiguous viewpoint. Объектно-ориентированные модели анализа и дизайна
представляются без внесения ясности в особенности модели. Изначально эти модели
обозначаются с точки зрения визуализации структуры программы. Двусмысленные
точки зрения не поддерживают фундаментального разделения интерфейсов и деталей
представления.

Boat anchor. «Корабельный Якорь» – часть бесполезного компьютерного «железа»,
единственное применение для которого – отправить на утилизацию. Этот термин
появился в то время, когда компьютеры были больших размеров. В настоящее время
термин «Корабельный Якорь» стал означать классы и методы,, которые по различным
причинам не имеют какого-либо применения в приложении и в принципе бесполезны.
Они только отвлекают внимание от действительно важного кода.

Busy spin. Техника, при которой процесс непрерывно проверяет изменение
некоторого состояния, например ожидает ввода с клавиатуры или разблокировки
объекта. В результате повышается загрузка процессора, ресурсы которого можно
было бы перенаправить на исполнения другого процесса. Альтернативным путем
является использование сигналов. Большинство ОС поддерживают погружение потока в
состояние «сон» до тех пор, пока ему отправит сигнал другой поток в результате
изменения своего состояния.

Caching Failure. «Кэширование Ошибки» – тип программного бага (bug), при котором
приложение сохраняет (кэширует) результаты, указывающие на ошибку даже после
того, как она исправлена. Программист исправляет ошибку, но флаг ошибки не
меняет своего состояния, поэтому приложение все еще не работает.

#patterns

---

# Facade

или _фасад_

Обеспечивает высокоуровневый интерфейс для больших блоков кода, скрывая их сложность.

![[Facade.png]]

### Когда использовать?

Когда нужно скрыть сложные системы под простым интерфейсом

---

https://refactoring.guru/design-patterns/facade

tags: #programming, #patterns

---

# Composite

Суть паттерна заключается в сокращении различий в управлении группами объектов и
индивидуальными объектами. Рассмотрим управление солдатами в строю. Существует
некий свод правил, который определяет как командовать строем, согласно этого
свода не важно кому отдается приказ (например «шагом марш») – одному солдату или
целому взводу. В такой свод правил нельзя включить команду, которую может
исполнить только один солдат, но не может исполнить группа и наоборот.

#patterns

---

# Mediator

или _медиатор_, _посредник_

Ядро какого-либо приложения, позволяющее добавлять либо удалять подключаемые модули
