---
tags: [networking, wip]
---

# HTTP

Stands for **H**yper**T**ext **T**ransfer **P**rotocol

Исторически HTTP/1.1 имел некоторые проблемы - чувствительность к [[RTT]], конвейерная обработка запросов,
блокировка начала очереди, необходимость домен-шардинга. Поэтому была начата разработка HTTP2,
которая началась с протокола SPDY. Концептуально HTTP2 поддерживал стандарты HTTP/1.1,
это по-прежнему протокол, базирующийся на TCP, это по-прежнему схемы http:// и https://.
TLS-расширения NPN и [ALPN](https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation)
позволяют клиенту и серверу договориться какой протокол использовать

Вкратце, HTTP2 уменьшает количество необходимых приемов-передач, избегает дилеммы блокировки
начала очереди за счет [[Multiplexing|мультиплексирования]] и быстрого отклонения нежелательных
потоков, позволяет работать множеству потоков, позволяет приоритезировать потоки.

- HTTP2 - _бинарный протокол_ (HTTP был текстовым). Существует несколько типов фреймов,
  но все они имеют одинаковое строение: тип, длина, флаги, id потока и полезная нагрузка.
  _Потоков может быть много, они дешевы и [[Мультиплексирование!мультиплексируются]]_.
  _Потоки имеют приоритет_, например если в данный момент пользователь просматривает картинку,
  то поток передающий ее может получить более высокий приоритет
- HTTP2 - _протокол без состояния_, т. е. прикаждом запросе он должен передавать максимальное
  количество деталей, которые требуются серверу. Это делает запросы очень большими и им становится
  необходимо сжатие. В HTTP2 реализовано сжатие заголовков
- HTTP2 поддерживает _сброс_ (reset) с помощью типа фрейма RST_STREAM
- HTTP2 поддерживает _server push_. Если клиент просит ресурс _X_, то сервер может решить что клиент
  скоро попросит ресурс _Y_ и отправит его клиенту без просьбы с его стороны. Клиент должен явно
  разрешить _server push_ и может отменить посланный поток, если он оказался не нужен
- Каждый поток в HTTP2 имеет свое _окно потока_, которое другая сторона разрешила для передачи
  данных. Работает похоже на [[SSH]]. Для каждого потока оба конца сообщают что у них еще есть
  место для принятия и противоположному концу дозволено отправить только указанное количество данных
- HTTP2 поддерживает _расширения_ в виде новых типов фреймов. Промежуточным хостам запрещено изменять
  нестандартные фреймы. Например, тип ALTSVC позволяет сообщить клиенту о наличии нового сервиса
  который надо начать использовать, а тип BLOCKED используется для удобства релизации протокола
  и экспериментирования.

## Выводы

- CSS-спрайты и _image Inlining_ не должны использоваться с HTTP2

# HTTP Caching

### Заголовок Cache-Control

No-Cache

---

https://roadmap.sh/guides/http-caching
https://proselyte.net/tutorials/http-tutorial/caching/

---

!! Вопросы

;Какие проблемы были у HTTP/1.1?
:Чувствительность к RTT, конвейреная обработка запросов, блокировка начала очереди, необходимость домен-шардинга
;Что нового в HTTP/2 по сравнению с HTTP/1.1?
:Бинарный протокол, мультиплексирование потоков, reset, server push, расширения

---

https://proselyte.net/tutorials/http-tutorial/

# HTTP Status Codes

**1xx**: Информационные
**2xx**: Успешное выполнение
**3xx**: Перенаправление
**4xx**: Ошибка на стороне клиента
**5xx**: Ошибка на стороне сервера



HTTP (Java)

- #read [HTTP Specification](https://datatracker.ietf.org/doc/html/rfc2616)


Request

```bash
POST /boxes?color=red HTTP/1.1    # Method + Path & Query params + Version

host: www.example.com             # Headers
accept: application/json
content-type: application/json

{                                 # Response Body (ex: JSON)
	"size": "small"
}
```

Response

```bash
HTTP/1.1 200 OK                   # HTTP Version + Status code + Reason Phrase

etag: "511GaciaHb28"              # Headers
content-length: 23
content-type: application/json

{				                  # Response Body (ex: JSON)
	"success": true
}
```

[[HTTP Headers]]




- Authorization
- Content-Type
- Accept
- Content-Length
- Cache
- ETag

"x-*" prefix

- #todo Learn more about headers